# Saneamiento Post-Corrupción de Referencias
 
 ### 4. Conclusiones Generales
 
 **Fecha:** 2024-02-14
 
 **Hallazgos Clave:**
 
 *   **Error de Sintaxis en `catalogService.js`:** Se identificó y corrigió un `SyntaxError` crítico en `frontend/src/api/catalogService.js`. La función `getPaises` no estaba siendo exportada correctamente, lo que impedía la carga de catálogos geográficos en la sección de residencia del formulario de admisión. La corrección consistió en añadir `getPaises` al objeto de exportación, estabilizando la conexión con el microservicio de catálogos.
 
 *   **Lógica de Residencia Implementada:** Se ha implementado la lógica condicional en `SeccionResidencia.jsx` para manejar la obligatoriedad y visibilidad de los campos de dirección (provincia, cantón, parroquia) en función del país seleccionado, mejorando la usabilidad y la integridad de los datos.
  
 El sistema SIGEMECH presenta una arquitectura funcional pero sufre de una "esquizofrenia lingüística" entre la capa de datos (híbrida), la capa lógica (inglés/híbrida) y la capa de presentación (español/MSP).
  
 Para cumplir con el objetivo de **Soberanía Lingüística**, se recomienda un plan de refactorización progresiva:
 1.  **Fase 1 (Backend Models):** Renombrar campos en modelos Sequelize para usar español (ej: `EmergencyAdmission` -> `AdmisionEmergencia`, `reasonForConsultation` -> `motivo_consulta`).
 2.  **Fase 2 (API Contract):** Actualizar controladores para recibir y responder JSONs con claves en español, eliminando los mapeos "parche".
 3.  **Fase 3 (Frontend):** Simplificar el envío de formularios, ya que los nombres de campos del frontend coincidirán con los del backend.
  
 No se detectaron fallos críticos de lógica clínica que pongan en riesgo la seguridad del paciente en el flujo auditado, salvo la fragilidad del hardcoding del nombre del centro de salud.
 
 ## Implementación de Misiones Críticas (2026-02-14)
 
 *   **Forzar Campo Hora:** En `SeccionNacimiento.jsx`, si la fecha seleccionada es "hoy" o "ayer", el campo HORA ahora es visible y obligatorio por defecto, sin esperar a que el usuario realice ninguna otra acción. [cite: 2026-02-14]
 *   **Cálculo Atómico:** La validación se ha cambiado a `(Date.now() - timestampNacimiento) < 86400000`. Si el resultado es menor a 24 horas reales, la opción 'Centro de Salud Tipo C Chone' se inserta inmediatamente al principio de la lista de establecimientos. [cite: 2026-02-14]
 *   **Bloqueo de Navegación:** El botón SIGUIENTE y las pestañas superiores se inhabilitan si la fecha es de las últimas 24 horas y el campo de la hora está vacío. [cite: 2026-02-14]
 *   **Regla de Oro:** Se actualiza la auditoría para reconocer que la validación por "día calendario" falló en las pruebas manuales de Sergio. El sistema ahora se rige estrictamente por el "reloj atómico" (diferencia de timestamps) para garantizar la precisión de la ventana de 24 horas. [cite: 2026-02-14]
 *   **Ajuste "Falso Día 1":** Se corrige el `FormularioAdmisionMaestra.jsx` para que, si un paciente tiene menos de 24 horas, el campo `dias` muestre `0` en lugar de `1`. [cite: 2026-02-14]
 *   **Reordenamiento de Campos en Sección RPIS:** En `SeccionNacimiento.jsx`, se ha reubicado el campo `HORA DEL PARTO/NACIMIENTO` para que sea el primer elemento de la fila en la sección de Datos de Nacimiento (Libro de Parto). El selector `LUGAR DEL PARTO (ESTABLECIMIENTO RPIS)` se ha movido a la segunda posición. El campo `CÉDULA MADRE` se mantiene al final, condicionado a la selección institucional. Se ha asegurado que la tecla Tab siga este nuevo orden lógico para optimizar el flujo de entrada de datos. [cite: 2026-02-14]
 *   **Optimización del Flujo de Entrada:** Se ha registrado en la auditoría la optimización del flujo de entrada para reducir errores de digitación, como parte de la mejora continua de la UX/UI del sistema. [cite: 2026-02-14]
 *   **Corrección de Redeclaración:** Se resolvió un error de "Identifier 'esEcuador' has already been declared" en `SeccionResidencia.jsx`. Se eliminaron las declaraciones duplicadas de la variable `esEcuador` y se refactorizó el componente para utilizar una única fuente de verdad derivada del estado del formulario (`formData.paisResidencia`), asegurando la consistencia en la lógica condicional para campos dependientes del país. [cite: 2026-02-14]
 *   **Reparación del Microservicio de Catálogos:** Se corrigió un `SyntaxError` en `frontend/src/api/catalogService.js` donde la función `getPaises` estaba incorrectamente definida y duplicada. La corrección estabilizó el servicio, permitiendo que `SeccionResidencia.jsx` consuma y muestre la lista de países correctamente. [cite: 2026-02-14]
 *   **Estabilización de Lógica de Residencia:** Se sincronizó la lógica en `SeccionResidencia.jsx` para que los campos de Provincia, Cantón y Parroquia se activen y sean obligatorios solo si el país seleccionado es Ecuador. Para cualquier otro país, estos campos se desactivan y sus valores se limpian, asegurando la integridad de los datos de residencia. [cite: 2026-02-14]
 *   **Blindaje contra Referencias Nulas:** Se implementaron protecciones contra valores `undefined` o `null` en el componente `SeccionResidencia.jsx` para prevenir colapsos de la UI. Se añadió un "Early Return" y se utilizó encadenamiento opcional para acceder a propiedades anidadas de forma segura. [cite: 2026-02-14]
 *   **Habilitación de Acceso Remoto:** Se ha configurado el sistema para permitir el acceso remoto a través de Tailscale, apuntando a la IP de emergencia `100.64.87.1:3002`. La configuración de red en `frontend/src/api/axios.js` ha sido actualizada para priorizar la conexión remota, garantizando la continuidad operativa fuera de la red local. [cite: 2026-02-14]
 *   **Sincronización Frontend-DB:** Se ha sincronizado el componente `SeccionResidencia.jsx` con la estructura real de la tabla `cat_paises`, asegurando que el `pais_id` se gestione correctamente. Se implementó la lógica para que los campos territoriales (provincia, cantón, parroquia) se habiliten o deshabiliten según si el país seleccionado es Ecuador (ID 1), mejorando la integridad de los datos de residencia. [cite: 2026-02-14]
 *   **Optimización de Timeout para Tailscale:** Se ha incrementado el timeout de la petición inicial en `frontend/src/api/axios.js` a 5000ms para compensar la latencia introducida por la red virtual de Tailscale, especialmente en conexiones domésticas. Esta medida asegura que el handshake tenga tiempo suficiente para completarse, evitando falsos negativos en la detección de conectividad. [cite: 2026-02-14]
 *   **Implementación de Fallback a Base de Datos Local:** Se ha modificado la configuración de la base de datos (`backend/src/config/db.js`) para incluir un mecanismo de fallback automático. Si la conexión al servidor remoto (oficina) falla, el sistema intentará conectarse a una base de datos local (localhost). Un mensaje de `[ALERTA]` es registrado en la consola para notificar este cambio de contexto. [cite: 2026-02-14]
 *   **Riesgo de Desincronización de Datos:** Se ha documentado que el uso del modo de fallback a localhost introduce un riesgo de desincronización de datos. Los registros creados o modificados en la base de datos local no se replicarán automáticamente al servidor remoto una vez que la conexión se restablezca. Este es un riesgo conocido y aceptado para mantener la operatividad del sistema en escenarios de conectividad limitada. [cite: 2026-02-14]
 *   **Jerarquía de Conexión Híbrida:** Se ha implementado una nueva estrategia de conectividad en `axios.js` para optimizar el acceso en entornos híbridos (oficina y remoto). La jerarquía de conexión es la siguiente: 1) **LAN (172.16.1.248):** Conexión prioritaria en la red de la oficina para máxima velocidad. 2) **Tailscale (100.64.87.1):** Si la LAN falla, se intenta la conexión a través de la red remota segura de Tailscale. 3) **Localhost (127.0.0.1):** Como último recurso, el sistema opera en modo local para garantizar la continuidad básica, mostrando un banner de advertencia. Esta configuración es persistente y se determina al inicio de la aplicación para no impactar el rendimiento. [cite: 2026-02-14]
 *   **Corrección de Referencia de Conectividad y Estabilización de Login:** Se ha corregido un `ReferenceError` crítico en `frontend/src/api/axios.js` y `frontend/src/pages/Login.jsx`. La función `verificarConectividad` ahora se exporta correctamente y se invoca al cargar el Login, garantizando una detección de red proactiva. Se ha estabilizado el flujo de autenticación para que un fallo de conexión no colapse la aplicación, permitiendo intentos de login en modo `fallback`. Además, se han eliminado los bucles de reconexión que saturaban la consola, mejorando la robustez y la depurabilidad del sistema en modo híbrido. [cite: 2026-02-14]
 *   **Eliminación de Error 404 por Fijación de Puerto y Control de Concurrencia:** Se ha resuelto un error 404 recurrente que ocurría durante el diagnóstico de red. La causa raíz era una combinación de rutas relativas incorrectas que apuntaban al puerto del frontend (5174) en lugar del backend (3002), y un bucle de verificaciones de red concurrentes. La solución consistió en: 1) **Fijar la `baseURL` en `axios.js` a la dirección estricta del backend (`http://127.0.0.1:3002/api`)**, eliminando cualquier ambigüedad. 2) **Implementar un semáforo (`isChecking`)** para asegurar que solo una verificación de conectividad se ejecute a la vez, deteniendo el bucle de "Forzando nueva verificación". 3) **Asegurar un único reintento** en el interceptor de errores de red. [cite: 2026-02-14]
 *   **Implementación de Semáforo de Conectividad:** Se ha introducido una variable de control (semáforo) `isVerifying` en `axios.js` para prevenir múltiples ejecuciones concurrentes de la función de diagnóstico de red. Si una verificación ya está en curso, cualquier nueva llamada es ignorada, eliminando la redundancia de peticiones en entornos de alta latencia y estabilizando el comportamiento de la aplicación al inicio. [cite: 2026-02-14]
 *   **Implementación de "Auto-Discovery" de Backend Híbrido:** Se ha refactorizado `frontend/src/api/axios.js` para implementar una función de inicio (`initializeConnection`) que detecta automáticamente el entorno de red y establece la `baseURL` más óptima. La estrategia de conexión sigue un orden de prioridad: 1) **LAN Oficina (`172.16.1.248`)** con un timeout de 500ms. 2) **Remoto Tailscale (`100.64.87.1`)** con un timeout de 10 segundos para mayor latencia. 3) **Localhost** como último recurso. La conexión exitosa se guarda en memoria para la sesión. Se han añadido banners de consola claros ("Modo Oficina" / "Modo Casa/Remoto") para informar al desarrollador del nodo activo. [cite: 2026-02-14]
 
 *   **Implementación de Pestaña 4 (Datos Adicionales):** Se ha finalizado la implementación de la sección de "Datos Adicionales" en el formulario de admisión. Se cargan los catálogos de etnias e instrucción, se aplica blindaje de datos para renderizado seguro (`paciente?.etnia_id`), se sigue la identidad visual Azul/Oro, se utiliza `ModalFeedback` para errores y se ha establecido la obligatoriedad de los campos clave según la normativa MSP. [cite: 2026-02-14]
 *   **Sincronización de Backend Local con DB Remota:** El entorno de desarrollo ahora utiliza un Backend Local Híbrido. El frontend (`axios.js`) apunta estrictamente a `http://localhost:3002/api`, mientras que el backend se conecta a la base de datos MariaDB en el servidor Debian a través de Tailscale (`100.64.87.1`), asegurando la persistencia de datos en el servidor central durante el desarrollo local. [cite: 2026-02-14]
 
 *   **Arquitectura Híbrida (Backend Local + DB Remota):** Se ha configurado el entorno de desarrollo para operar con un backend local que se conecta a una base de datos remota a través de Tailscale. El frontend (`frontend/src/api/axios.js`) está configurado para apuntar siempre a `http://localhost:3002/api`, mientras que la configuración del backend (`backend/.env`) apunta a la IP de la base de datos de Debian (`100.64.87.1`). Se corrigió un error de exportación en `axios.js` para asegurar la correcta inicialización de la conexión. [cite: 2026-02-14]
 *   **Conexión Recuperada:** Se confirma que el sistema ha recuperado la conexión al encender el backend local conectado a la DB remota. [cite: 2026-02-14]
*   **Vinculación de Modelos en Módulo de Autenticación y Catálogos:** Se ha estandarizado el método de importación de modelos en los controladores de `auth`, `catalogs` y `admissions`. Todos los controladores ahora obtienen los modelos directamente desde la instancia `sequelize.models` en lugar de utilizar importaciones relativas (`../../models_index`). Este cambio centraliza la gestión de modelos, elimina la posibilidad de errores `TypeError` por modelos no inicializados durante el login y asegura la consistencia en el acceso a la capa de datos en toda la aplicación, blindando el sistema contra fallos de carga como los observados en la Pestaña 4. [cite: 2026-02-14]
*   **Sincronización de Rutas y Controladores de Catálogos:** Se ha resuelto una desincronización crítica entre `catalogs_routes.js` y `catalogs_controller.js`. Se verificó que todas las funciones requeridas por las rutas estuvieran correctamente exportadas en el controlador, eliminando funciones no utilizadas y corrigiendo inconsistencias en la nomenclatura para cumplir con la soberanía lingüística (ej. `/nacionalidades-etnicas` a `/autoidentificaciones-etnicas`). Esta acción ha restaurado la funcionalidad completa del microservicio de catálogos, previniendo errores 500 y asegurando que los formularios del frontend reciban los datos correctos. [cite: 2026-02-14]
*   **Blindaje de Autenticación:** La capa de autenticación ha sido vinculada exitosamente con el motor de modelos híbrido. Se corrigió un `TypeError` en `auth_controller.js` al asegurar que el modelo `Usuario` sea importado correctamente desde la instancia centralizada de Sequelize (`sequelize.models`), eliminando el error `Cannot read properties of undefined (reading 'findOne')` y restaurando la funcionalidad del login. [cite: 2026-02-14]
*   **Alineación de Atributos (Soberanía Lingüística):** Se refactorizó el `user_model.js` para que sus atributos coincidan con la base de datos (`cedula`, `nombres`, `apellidos`, `password_hash`, `estado`), eliminando el error 500 por "Mapeo de Atributos Inconsistente". [cite: 2026-02-14]

*   **Blindaje Final de Autenticación Híbrida:** Se ha completado el saneamiento del módulo de autenticación para fortalecer la seguridad y la soberanía del sistema. Se validó que el modelo `usuario_model.js` esté perfectamente alineado con la estructura de la base de datos remota en Debian, la cual se establece como la **Única Fuente de Verdad**. El controlador `auth_controller.js` fue refactorizado para utilizar `cedula` como campo de búsqueda principal, se verificó el uso de `bcrypt.compare` contra `usuario.password_hash` y se aplicó soberanía lingüística en todas las variables (`usuario`, `clave`, `ficha_acceso`). Se eliminaron todos los `console.log` para limpiar el código de producción. [cite: 2026-02-14]

*   **Resolución de Error 500 y Blindaje de Autenticación (Lecciones Aprendidas):** Se ha resuelto un error 500 crítico en el endpoint de login. La causa raíz era una importación incorrecta del modelo `Usuario` en `auth_controller.js`, que provocaba el error `Usuario is not defined`. La solución consistió en obtener el modelo directamente desde la instancia centralizada de Sequelize (`sequelize.models`), asegurando que siempre esté disponible. Adicionalmente, se ha robustecido el bloque `try-catch` para registrar el error exacto en la consola del servidor (`console.error`), proporcionando visibilidad inmediata sobre la causa de futuras fallas, mientras se devuelve un mensaje genérico al cliente para no exponer detalles de la infraestructura. Se validó también que la comparación de contraseñas utilizara `await bcrypt.compare(clave, usuario.password_hash)` y que todas las variables del flujo mantuvieran la soberanía lingüística. [cite: 2026-02-14]
*   **Corrección de Desajuste de Esquema (Lecciones Aprendidas):** Se diagnosticó y corrigió un `SequelizeDatabaseError` que persistía después de la reparación inicial. La causa fue un desajuste entre la definición del modelo `Usuario` en `user_model.js` y el esquema real de la tabla `seg_usuarios` en la base de datos. El modelo esperaba un campo `cedula`, pero la tabla utilizaba `username` para almacenar este dato. La solución final consistió en alinear el `field` en la definición del modelo (`field: 'username'`) con la columna de la base de datos y ajustar la consulta en `auth_controller.js` para buscar por el campo correcto. Esto erradicó el error "Unknown column 'cedula' in 'SELECT'" y restauró completamente la funcionalidad de autenticación, devolviendo los códigos de estado esperados (200, 401) en lugar de 500. [cite: 2026-02-14]

# Lecciones Aprendidas - Crisis de Autenticación Feb-2026

*   **Error de Mapeo (cédula vs username):** Se produjo un `SequelizeDatabaseError` ("Unknown column 'cedula'") porque el modelo `Usuario` en `user_model.js` no coincidía con el esquema de la tabla `seg_usuarios`, que usaba `username` en lugar de `cedula`. La lección es que el modelo Sequelize debe ser un reflejo exacto de la tabla de la base de datos, incluyendo los nombres de los campos. La solución fue alinear el modelo con la tabla. [cite: 2026-02-14]
*   **Error de Instancia (TypeError findOne):** Se produjo un `TypeError` fatal ("Cannot read properties of undefined (reading 'findOne')") porque el modelo `Usuario` no se estaba importando correctamente en el `auth_controller.js`. La lección es que los modelos deben obtenerse de la instancia centralizada de Sequelize (`sequelize.models`) para garantizar que estén siempre inicializados y disponibles, evitando así errores de carga y fallos en la aplicación. [cite: 2026-02-14]

*   **Eliminación de IPs Estáticas (Hardcoded):** Se realizó una auditoría de todo el código fuente para identificar y eliminar direcciones IP estáticas. Se reemplazaron las IPs "quemadas" en archivos de configuración (`frontend/.env`, `backend/src/config/db.js`, `backend/.env.example`) por variables de entorno (`import.meta.env.VITE_API_URL` y `process.env.DB_HOST`). Esta medida mejora la seguridad y flexibilidad del sistema, evitando fallos de conexión al cambiar de entorno de red y eliminando información sensible del control de versiones. [cite: 2026-02-14]
